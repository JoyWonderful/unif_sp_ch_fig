import json
from os import path

UNIFONT_VERSION = "17.0.03"
CURRENT_DIR = path.dirname(path.abspath(__file__)) + "/" # ./
INPUT_FILE = CURRENT_DIR + "assets/unifont/unifont.hex"
INPUT_SP_CHINESE_CH_FILE = CURRENT_DIR + "assets/gb2312-chinese.modify.txt"
OUTPUT_JSON = CURRENT_DIR + "assets/unifont/unifont.json"
FLF_SCOPE_ARR = [
    #[0x0020, 0x007E], # Part of "Controls and basic latin". The necessary FIGfont
    #[0x4E00, 0x9FFF], # 基本汉字，太多了，不用，使用 INPUT_SP_CHINESE_CH_FILE 生成
    [0x3000, 0x3002], [0x3007, 0x3011], [0x3014, 0x301B], # 部分中文符号和标点
    [0xFF0C, 0xFF0C], # ，  逗号
    [0xFF01, 0xFF01], # ！  感叹号
    [0xFF1F, 0xFF1F], # ？  问号
    [0xFF1A, 0xFF1B], # ：；  冒号 分号
    [0x2014, 0x2014], # —  破折号
    [0x2026, 0x2026], # …  省略号
    [0xFFE5, 0xFFE5]  # ￥  人民币
]

dic = {}
bin_dic = {}
HEX2BIN = {"0":"0000", "1":"0001", "2":"0010", "3":"0011",
    "4":"0100", "5":"0101", "6":"0110", "7":"0111",
    "8":"1000", "9":"1001", "A":"1010", "B":"1011",
    "C":"1100", "D":"1101", "E":"1110", "F":"1111"}


## Get Simplified Chinese characters required to generate
with open(INPUT_SP_CHINESE_CH_FILE, "r", encoding="utf-8") as f:
    ch_arr:list = f.readlines()
    for ch in ch_arr:
        ch_code = ord(ch.replace("\n", ""))
        FLF_SCOPE_ARR += [[ch_code, ch_code]]
# FLF_SCOPE_ARR won't be changed anymore. So I regard it as an constant variable


## Write .hex to dict
with open(INPUT_FILE, "r") as f:
    line_arr:list = f.readlines()
    for line in line_arr:
        tmparr:list = line.replace("\n", "").split(":")
        dic.update({int("0x"+tmparr[0],base=16): tmparr[1]})


## Write JSON
def generate_json(output_json = OUTPUT_JSON):
    with open(output_json, "w", encoding="utf-8") as f:
        f.write(json.dumps(dic, indent=0))


def generate_bin_dic(output_dic:dict, flf_scope_arr:list=FLF_SCOPE_ARR):
    for scope in flf_scope_arr+[[0x0020,0x007E]]:
        for i in range(scope[0], scope[1]+1):
            bin_str = ""
            hex_ch:str = dic[i]
            line_break_cnt = 4 # when to break(based on hex digits)
            if(len(hex_ch) == 32): line_break_cnt = 2
            cnt = 0 # how many hex digits have read for each line?
            # begin convert hex to bin string
            for ch in hex_ch:
                cnt += 1
                bin_str += HEX2BIN[ch]
                if(cnt % line_break_cnt == 0 and cnt != len(hex_ch)): # line break
                    bin_str += "\n"
            # end convert
            output_dic.update({i: bin_str.split("\n")})

## To Binary String FigFont
def generate_flf(output_flf:str, _bin_dic:dict, flf_scope_arr:list=FLF_SCOPE_ARR, ch_fill="\u2588\u2588", ch_blank="  "): # ch_fill = "██"
    nreq_ctag_cnt = 0
    for scope in flf_scope_arr:
        nreq_ctag_cnt += scope[1]-scope[0]+1
    flf_header = f"""flf2a$ 16 14 34 -1 5 0 0 {nreq_ctag_cnt}
File is generated by unif-sp-ch-fig.
Convert unifont <https://unifoundry.com/unifont/> (especially for Chinese characters) to FIGfont file.
License of this FIGfont and unifont is SIL OPEN FONT LICENSE Version 1.1(OFL 1.1), see LICENSE.txt.
height:16; baseline:14; max_length:32+2; old_layout:full_size; comment_lines:5; print_direction:left-to-right; full_layout:0; none_required_codetag_count:{nreq_ctag_cnt}

"""
    binary_str_file=open(output_flf, "w", encoding="utf-8")
    binary_str_file.write(flf_header)
    # begin required characters
    for i in range(0x0020, 0x007E+1):
        bin_str = "@\n".join(_bin_dic[i]) + "@@\n"
        binary_str_file.write(f"{bin_str.replace("1", ch_fill).replace("0", ch_blank)}")
    for i in range(0, 7): #[0x00C4,0x00D6,0x00DC,0x00E4,0x00F6,0x00FC,0x00DF]
        binary_str_file.write("@\n"*15 + "@@\n")
    # end required characters
    # unrequired code tags(主要是中文字符)
    for scope in FLF_SCOPE_ARR:
        for i in range(scope[0], scope[1]+1):
            bin_str = "@\n".join(_bin_dic[i]) + "@@\n"
            binary_str_file.write(f"{hex(i)} {chr(i)}\n{bin_str.replace("1", ch_fill).replace("0", ch_blank)}")
    binary_str_file.close()

if __name__ == "__main__":
    generate_bin_dic(output_dic=bin_dic)
    generate_flf(output_flf=CURRENT_DIR+"fig-fonts/chinese_solid_box_big.flf", _bin_dic=bin_dic)

