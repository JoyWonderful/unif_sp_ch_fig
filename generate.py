"""
Generate FIGfonts from unifont glyghs.

Unifont glyghs is licensed under dual-licensed under the OFL1.1 and GPL2.0,
see assets/unifont/COPYING.txt.
The source code is licensed under GPL2.0. See the notice below and LICENSE.txt.
The generated fonts are licensed under OFL1.1. See fig-fonts/LICENSE.txt.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
import json
from os import path

UNIFONT_VERSION = "17.0.03"
CURRENT_DIR = path.dirname(path.abspath(__file__)) + "/" # ./
INPUT_FILE = CURRENT_DIR + "assets/unifont/unifont.hex"
INPUT_SP_CHINESE_CH_FILE = CURRENT_DIR + "assets/gb2312-chinese.modify.txt"
OUTPUT_JSON = CURRENT_DIR + "assets/unifont/unifont.json"
FLF_SCOPE_ARR = [
    #[0x0020, 0x007E], # Part of "Controls and basic latin". The necessary FIGfont
    #[0x4E00, 0x9FFF], # 基本汉字，太多了，不用，使用 INPUT_SP_CHINESE_CH_FILE 生成
    [0x3000, 0x3002], [0x3007, 0x3011], [0x3014, 0x301B], # 部分中文符号和标点
    [0xFF0C, 0xFF0C], # ，  逗号
    [0xFF01, 0xFF01], # ！  感叹号
    [0xFF1F, 0xFF1F], # ？  问号
    [0xFF1A, 0xFF1B], # ：；  冒号 分号
    [0x2014, 0x2014], # —  破折号
    [0x2026, 0x2026], # …  省略号
    [0xFFE5, 0xFFE5]  # ￥  人民币
]

dic = {} # This dict is to store the hex file
HEX2BIN = {"0":"0000", "1":"0001", "2":"0010", "3":"0011",
    "4":"0100", "5":"0101", "6":"0110", "7":"0111",
    "8":"1000", "9":"1001", "A":"1010", "B":"1011",
    "C":"1100", "D":"1101", "E":"1110", "F":"1111"}


## Get Simplified Chinese characters required to generate
with open(INPUT_SP_CHINESE_CH_FILE, "r", encoding="utf-8") as f:
    ch_arr:list = f.readlines()
    for ch in ch_arr:
        ch_code = ord(ch.replace("\n", ""))
        FLF_SCOPE_ARR += [[ch_code, ch_code]]
# FLF_SCOPE_ARR won't be changed anymore. So I regard it as an constant variable


## Write .hex to dict
with open(INPUT_FILE, "r") as f:
    line_arr:list = f.readlines()
    for line in line_arr:
        tmparr:list = line.replace("\n", "").split(":")
        dic.update({int("0x"+tmparr[0],base=16): tmparr[1]})


## Write JSON
def generate_json(output_json = OUTPUT_JSON):
    """
    Generate JSON file of unifont glyphs.

    :param output_json: The output JSON file
    """
    with open(output_json, "w", encoding="utf-8") as f:
        f.write(json.dumps(dic, indent=0))


def generate_bin_dic(flf_scope_arr:list=FLF_SCOPE_ARR):
    """
    Generate the 0-1 strings for unifont glyphs in `flf_scope_arr`
    
    :param flf_scope_arr: A list of unicode scopes.\n\n\
        The list should contain several lists of scope.\n\n\
        e.g. `[[0x4E00,0x9FFF],[0x0020,0x0020]]`.
    :type flf_scope_arr: list
    :return: A dict like `{unicode: [lists of 0-1 string]}`.\n\n\
        Every string in the list corresponds a line.\n\n\
        e.g. `{1:["01010101","01010101","01010101",...],...}`
    :rtype: dict
    """
    ret_dic = {}
    for scope in flf_scope_arr+[[0x0020,0x007E]]:
        for i in range(scope[0], scope[1]+1):
            bin_str = ""
            hex_ch:str = dic[i]
            line_break_cnt = 4 # when to break(based on hex digits)
            if(len(hex_ch) == 32): line_break_cnt = 2
            cnt = 0 # how many hex digits have read for each line?
            # begin convert hex to bin string
            for ch in hex_ch:
                cnt += 1
                bin_str += HEX2BIN[ch]
                if(cnt % line_break_cnt == 0 and cnt != len(hex_ch)): # line break
                    # not:last line(if don't use `and cnt != len(hex_ch)`, the FIGcharacter's end will be like: `{data}@\n@@\n` ,but expected `{data}@@\n`)
                    bin_str += "\n"
            # end convert
            ret_dic.update({i: bin_str.split("\n")})
    return ret_dic

## To Binary String FigFont
def generate_flf(output_flf:str, bin_dic:dict, flf_scope_arr:list=FLF_SCOPE_ARR, ch_fill="\u2588\u2588", ch_blank="  "): # ch_fill = "██"
    """
    Generate FIGfont file.\n\n
    You're supposed to make sure the generated files are small enough to be read by the FIGdrivers.
    
    :param output_flf: Where the FIGfont file should be generate.
    :type output_flf: str
    :param bin_dic: The 0-1 string of FIGcharacters. Generated by `generate_bin_dic()`
    :type bin_dic: dict
    :param flf_scope_arr: A list of unicode scopes to be put in the FIGfont file.\n\n\
        The list should contain several lists of scope.\n\n\
        e.g. `[[0x4E00,0x9FFF],[0x0020,0x0020]]`. The scope must be included by `bin_dic`.
    :type flf_scope_arr: list
    :param ch_fill: Which character to replace "1" in the 0-1 string. It length is 2.
    :type ch_fill: str
    :param ch_blank: Which character to replace "0" in the 0-1 string. It length is 2.
    :type ch_blank: str

    :return: Although it writes FIGfont, it also return a dict like `bin_dic`,\
        but replace the 0-1 with `ch_fill` & `ch_blank`.
    :rtype: dict
    """
    ret_dic = {}
    nreq_ctag_cnt = 0
    for scope in flf_scope_arr:
        nreq_ctag_cnt += scope[1]-scope[0]+1
    flf_header = f"""flf2a$ 16 14 34 -1 5 0 0 {nreq_ctag_cnt}
File is generated by unif-sp-ch-fig.
Convert unifont <https://unifoundry.com/unifont/> (especially for Chinese characters) to FIGfont file.
License of this FIGfont and unifont is SIL OPEN FONT LICENSE Version 1.1(OFL 1.1), see LICENSE.txt.
height:16; baseline:14; max_length:32+2; old_layout:full_size; comment_lines:5; print_direction:left-to-right; full_layout:0; none_required_codetag_count:{nreq_ctag_cnt}

"""
    binary_str_file=open(output_flf, "w", encoding="utf-8")
    binary_str_file.write(flf_header)
    # begin required characters
    for i in range(0x0020, 0x007E+1):
        ret_dic.update({i: list(map(lambda line:line.replace("1",ch_fill).replace("0",ch_blank), bin_dic[i]))})
        bin_str = "@\n".join(bin_dic[i]) + "@@\n"
        binary_str_file.write(f"{bin_str.replace("1", ch_fill).replace("0", ch_blank)}")
    for i in range(0, 7): #[0x00C4,0x00D6,0x00DC,0x00E4,0x00F6,0x00FC,0x00DF]
        binary_str_file.write("@\n"*15 + "@@\n")
    # end required characters
    # unrequired code tags(主要是中文字符)
    for scope in FLF_SCOPE_ARR:
        for i in range(scope[0], scope[1]+1):
            ret_dic.update({i: list(map(lambda line:line.replace("1",ch_fill).replace("0",ch_blank), bin_dic[i]))})
            bin_str = "@\n".join(bin_dic[i]) + "@@\n"
            binary_str_file.write(f"{hex(i)} {chr(i)}\n{bin_str.replace("1", ch_fill).replace("0", ch_blank)}")
    binary_str_file.close()
    return ret_dic

if __name__ == "__main__":
    default_bin_dic:dict = generate_bin_dic()
    font_solid_box_big=generate_flf(output_flf=CURRENT_DIR+"fig-fonts/chinese_solid_box_big.flf", bin_dic=default_bin_dic)

